/// @title NFT positions
/// @notice Wraps Uniswap V3 positions in the ERC721 non-fungible token interface
/// @dev The address of the token descriptor contract, which handles generating token URIs for position tokens
archetype NonfungiblePositionManager(const factory: address, const WETH9: address, const tokenDescriptor: address)
// INonfungibleTokenPositionDescriptor
// address private immutable tokenDescriptor;

// pragma solidity =0.7.6;
// pragma abicoder v2;

// import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
// import '@uniswap/v3-core/contracts/libraries/FixedPoint128.sol';
// import '@uniswap/v3-core/contracts/libraries/FullMath.sol';

// import './interfaces/INonfungiblePositionManager.sol';
// import './interfaces/INonfungibleTokenPositionDescriptor.sol';
// import './libraries/PositionKey.sol';
// import './libraries/PoolAddress.sol';
// import './base/LiquidityManagement.sol';
// import './base/PeripheryImmutableState.sol';
// import './base/Multicall.sol';
// import './base/ERC721Permit.sol';
// import './base/PeripheryValidation.sol';
// import './base/SelfPermit.sol';
// import './base/PoolInitializer.sol';


function checkDeadline(deadline: date): bool {
    do_require(now <= deadline, "Transaction too old");
    return true
}

// receive tez
// receive() external payable {
//     require(msg.sender == WETH9, 'Not WETH9');
// }
entry default() {} // TODO+

/// @inheritdoc IPeripheryPayments
// function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {
//     uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));
//     require(balanceWETH9 >= amountMinimum, 'Insufficient WETH9');

//     if (balanceWETH9 > 0) {
//         IWETH9(WETH9).withdraw(balanceWETH9);
//         TransferHelper.safeTransferETH(recipient, balanceWETH9);
//     }
// }

/// @inheritdoc IPeripheryPayments
// function sweepToken(
//     address token,
//     uint256 amountMinimum,
//     address recipient
// ) public payable override {
//     uint256 balanceToken = IERC20(token).balanceOf(address(this));
//     require(balanceToken >= amountMinimum, 'Insufficient token');

//     if (balanceToken > 0) {
//         TransferHelper.safeTransfer(token, recipient, balanceToken);
//     }
// }

// /// @inheritdoc IPeripheryPayments
// function refundETH() external payable override {
//     if (address(this).balance > 0) TransferHelper.safeTransferETH(msg.sender, address(this).balance);
// }

/// @param token The token to pay
/// @param payer The entity that must pay
/// @param recipient The entity that will receive payment
/// @param value The amount to pay
// function pay(
//     address token,
//     address payer,
//     address recipient,
//     uint256 value
// ) internal {
//     if (token == WETH9 && address(this).balance >= value) {
//         // pay with WETH9
//         IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay
//         IWETH9(WETH9).transfer(recipient, value);
//     } else if (payer == address(this)) {
//         // pay with tokens already in the contract (for the exact input multihop case)
//         TransferHelper.safeTransfer(token, recipient, value);
//     } else {
//         // pull payment
//         TransferHelper.safeTransferFrom(token, payer, recipient, value);
//     }
// }

/// @notice The identifying key of the pool
record PoolKey {
    token0: address;
    token1: address;
    fee: nat; // uint24
}

record MintCallbackData {
    poolKey: PoolKey;
    payer: address;
}

record AddLiquidityParams {
    token0: address; // address;
    token1: address; // address;
    fee: nat; // uint24;
    recipient: address; // address;
    tickLower: int; // int24;
    tickUpper: int; // int24;
    amount0Desired: nat; // uint256;
    amount1Desired: nat; // uint256;
    amount0Min: nat; // uint256;
    amount1Min: nat; // uint256;
}

// constant name = "Uniswap V3 Positions NFT-V1";
// constant symbol = "UNI-V3-POS";
// constant nameHash = keccak256(bytes(name));
// constant versionHash = keccak256(bytes(1));
//     INonfungiblePositionManager,
//     Multicall,
//     ERC721Permit,
//     PeripheryImmutableState,
//     PoolInitializer,
//     LiquidityManagement,
//     PeripheryValidation,
//     SelfPermit
// {
    
// details about the uniswap position
record Position {
    // the nonce for permits
    nonce: nat; // uint96;
    // the address that is approved for spending this token
    operator: address; // address;
    // the ID of the pool with which this token is connected
    poolId: nat; // uint80;
    // the tick range of the position
    tickLower: int; // int24;
    tickUpper: int; // int24;
    // the liquidity of the position
    liquidity: nat; // uint128;
    // the fee growth of the aggregate position as of the last action on the individual position
    feeGrowthInside0LastX128: nat; // uint256;
    feeGrowthInside1LastX128: nat; // uint256;
    // how many uncollected tokens are owed to the position, as of the last computation
    tokensOwed0: nat; // uint128;
    tokensOwed1: nat; // uint128;
}

/// @dev IDs of pools assigned by this contract
// mapping(address => uint80) private _poolIds;
asset poolIds identified by pool to big_map {
    pool: address;
    poolId: nat = 0;
}

/// @dev Pool keys by pool ID, to save on SSTOREs for position data
// mapping(uint80 => PoolAddress.PoolKey) private _poolIdToPoolKey;
asset poolIdToPoolKey identified by poolId_ to big_map {
    poolId_: nat;
    poolKey: PoolKey;
}

/// @dev The token ID position data
// mapping(uint256 => Position) private positions_;
asset positions_ identified by tokenId_ to big_map {
    tokenId_: nat;
    position_: Position;
}

/// @dev The ID of the next token that will be minted. Skips 0
variable nextId_: nat = 1 // uint176 private
/// @dev The ID of the next pool that is used for the first time. Skips 0
variable nextPoolId_: nat = 1 // uint80 private

// constructor(
//     address _factory,
//     address _WETH9,
//     address tokenDescriptor_
// ) ERC721Permit('Uniswap V3 Positions NFT-V1', 'UNI-V3-POS', '1') PeripheryImmutableState(_factory, _WETH9) {
//     tokenDescriptor = tokenDescriptor_;
// }
// It should be process as metadata
// 'Uniswap V3 Positions NFT-V1', 'UNI-V3-POS', '1'

    /// @inheritdoc INonfungiblePositionManager
    view positions(tokenId: nat)
        // external
        // view
        // override
        : (
            /* nonce: */ nat,
            /* operator: */ address,
            /* token0: */ address,
            /* token1: */ address,
            /* fee: */ nat,
            /* tickLower: */ int,
            /* tickUpper: */ int,
            /* liquidity: */ nat,
            /* feeGrowthInside0LastX128: */ nat,
            /* feeGrowthInside1LastX128: */ nat,
            /* tokensOwed0: */ nat,
            /* tokensOwed1: */ nat
        )
    {
        // Position memory position = positions_[tokenId];
        // require(position.poolId != 0, 'Invalid token ID');
        // PoolAddress.PoolKey memory poolKey = poolIdToPoolKey[position.poolId];
        // return (
        //     position.nonce,
        //     position.operator,
        //     poolKey.token0,
        //     poolKey.token1,
        //     poolKey.fee,
        //     position.tickLower,
        //     position.tickUpper,
        //     position.liquidity,
        //     position.feeGrowthInside0LastX128,
        //     position.feeGrowthInside1LastX128,
        //     position.tokensOwed0,
        //     position.tokensOwed1
        // );
    }

    /// @dev Caches a pool key
    getter cachePoolKey(pool: address, poolKey: PoolAddress.PoolKey) 
    private returns 
    : nat /* poolId */ {
        // poolId = poolIds[pool];
        // if (poolId == 0) {
        //     poolIds[pool] = (poolId = nextPoolId_++);
        //     poolIdToPoolKey[poolId] = poolKey;
        // }
    }

    /// @inheritdoc INonfungiblePositionManager
    getter mint(params: MintParams)
        // external
        // payable
        // override
        // checkDeadline(params.deadline)
        // returns 
        (
            nat /* tokenId */,
            nat /* liquidity */,
            nat /* amount0 */,
            nat /* amount1 */
        )
    {
        // IUniswapV3Pool pool;
        // (liquidity, amount0, amount1, pool) = addLiquidity(
        //     AddLiquidityParams({
        //         token0: params.token0,
        //         token1: params.token1,
        //         fee: params.fee,
        //         recipient: address(this),
        //         tickLower: params.tickLower,
        //         tickUpper: params.tickUpper,
        //         amount0Desired: params.amount0Desired,
        //         amount1Desired: params.amount1Desired,
        //         amount0Min: params.amount0Min,
        //         amount1Min: params.amount1Min
        //     })
        // );

        // _mint(params.recipient, (tokenId = nextId_++));

        // bytes32 positionKey = PositionKey.compute(address(this), params.tickLower, params.tickUpper);
        // (, nat feeGrowthInside0LastX128, nat feeGrowthInside1LastX128, , ) = pool.positions(positionKey);

        // // idempotent set
        // nat poolId =
        //     cachePoolKey(
        //         address(pool),
        //         PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee})
        //     );

        // positions_[tokenId] = Position({
        //     nonce: 0,
        //     operator: address(0),
        //     poolId: poolId,
        //     tickLower: params.tickLower,
        //     tickUpper: params.tickUpper,
        //     liquidity: liquidity,
        //     feeGrowthInside0LastX128: feeGrowthInside0LastX128,
        //     feeGrowthInside1LastX128: feeGrowthInside1LastX128,
        //     tokensOwed0: 0,
        //     tokensOwed1: 0
        // });

        // emit IncreaseLiquidity(tokenId, liquidity, amount0, amount1);
    }

    function isAuthorizedForToken(tokenId: nat) : bool {
        // require(_isApprovedOrOwner(msg.sender, tokenId), 'Not approved');
        return true
    }

    entry tokenURI(tokenId: nat) 
    // public view override(ERC721, IERC721Metadata) 
    // returns (string memory) 
    : string
    {
        // require(_exists(tokenId));
        // return INonfungibleTokenPositionDescriptor(tokenDescriptor).tokenURI(this, tokenId);
    }

    // save bytecode by removing implementation of unused method
    function baseURI() 
    // public pure override returns (string memory) 
    : string
    {}

    /// @inheritdoc INonfungiblePositionManager
    getter increaseLiquidity(params: IncreaseLiquidityParams)
        // external
        // payable
        // override
        // checkDeadline(params.deadline)
        // returns 
        : (
            nat /* liquidity */,
            nat /* amount0 */,
            nat /* amount1 */
        )
    {
        // Position storage position = positions_[params.tokenId];

        // PoolAddress.PoolKey memory poolKey = poolIdToPoolKey[position.poolId];

        // IUniswapV3Pool pool;
        // (liquidity, amount0, amount1, pool) = addLiquidity(
        //     AddLiquidityParams({
        //         token0: poolKey.token0,
        //         token1: poolKey.token1,
        //         fee: poolKey.fee,
        //         tickLower: position.tickLower,
        //         tickUpper: position.tickUpper,
        //         amount0Desired: params.amount0Desired,
        //         amount1Desired: params.amount1Desired,
        //         amount0Min: params.amount0Min,
        //         amount1Min: params.amount1Min,
        //         recipient: address(this)
        //     })
        // );

        // bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);

        // // this is now updated to the current transaction
        // (, nat feeGrowthInside0LastX128, nat feeGrowthInside1LastX128, , ) = pool.positions(positionKey);

        // position.tokensOwed0 += nat(
        //     FullMath.mulDiv(
        //         feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,
        //         position.liquidity,
        //         FixedPoint128.Q128
        //     )
        // );
        // position.tokensOwed1 += nat(
        //     FullMath.mulDiv(
        //         feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,
        //         position.liquidity,
        //         FixedPoint128.Q128
        //     )
        // );

        // position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;
        // position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;
        // position.liquidity += liquidity;

        // emit IncreaseLiquidity(params.tokenId, liquidity, amount0, amount1);
    }

    /// @inheritdoc INonfungiblePositionManager
    entry decreaseLiquidity(params: DecreaseLiquidityParams)
        // external
        // payable
        // override
        // isAuthorizedForToken(params.tokenId)
        // checkDeadline(params.deadline)
        // returns 
        : (
            nat /* amount0 */, 
            nat /* amount1 */
        )
    {
        // require(params.liquidity > 0);
        // Position storage position = positions_[params.tokenId];

        // nat positionLiquidity = position.liquidity;
        // require(positionLiquidity >= params.liquidity);

        // PoolAddress.PoolKey memory poolKey = poolIdToPoolKey[position.poolId];
        // IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));
        // (amount0, amount1) = pool.burn(position.tickLower, position.tickUpper, params.liquidity);

        // require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');

        // bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);
        // // this is now updated to the current transaction
        // (, nat feeGrowthInside0LastX128, nat feeGrowthInside1LastX128, , ) = pool.positions(positionKey);

        // position.tokensOwed0 +=
        //     nat(amount0) +
        //     nat(
        //         FullMath.mulDiv(
        //             feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,
        //             positionLiquidity,
        //             FixedPoint128.Q128
        //         )
        //     );
        // position.tokensOwed1 +=
        //     nat(amount1) +
        //     nat(
        //         FullMath.mulDiv(
        //             feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,
        //             positionLiquidity,
        //             FixedPoint128.Q128
        //         )
        //     );

        // position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;
        // position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;
        // // subtraction is safe because we checked positionLiquidity is gte params.liquidity
        // position.liquidity = positionLiquidity - params.liquidity;

        // emit DecreaseLiquidity(params.tokenId, params.liquidity, amount0, amount1);
    }

    /// @inheritdoc INonfungiblePositionManager
    getter collect(params: CollectParams)
        // external
        // payable
        // override
        // isAuthorizedForToken(params.tokenId)
        // returns 
        :
        (
            nat /* amount0 */, 
            nat /* amount1 */
        )
    {
        // require(params.amount0Max > 0 || params.amount1Max > 0);
        // // allow collecting to the nft position manager address with address 0
        // address recipient = params.recipient == address(0) ? address(this) : params.recipient;

        // Position storage position = positions_[params.tokenId];

        // PoolAddress.PoolKey memory poolKey = poolIdToPoolKey[position.poolId];

        // IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));

        // (nat tokensOwed0, nat tokensOwed1) = (position.tokensOwed0, position.tokensOwed1);

        // // trigger an update of the position fees owed and fee growth snapshots if it has any liquidity
        // if (position.liquidity > 0) {
        //     pool.burn(position.tickLower, position.tickUpper, 0);
        //     (, nat feeGrowthInside0LastX128, nat feeGrowthInside1LastX128, , ) =
        //         pool.positions(PositionKey.compute(address(this), position.tickLower, position.tickUpper));

        //     tokensOwed0 += nat(
        //         FullMath.mulDiv(
        //             feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,
        //             position.liquidity,
        //             FixedPoint128.Q128
        //         )
        //     );
        //     tokensOwed1 += nat(
        //         FullMath.mulDiv(
        //             feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,
        //             position.liquidity,
        //             FixedPoint128.Q128
        //         )
        //     );

        //     position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;
        //     position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;
        // }

        // // compute the arguments to give to the pool#collect method
        // (nat amount0Collect, nat amount1Collect) =
        //     (
        //         params.amount0Max > tokensOwed0 ? tokensOwed0 : params.amount0Max,
        //         params.amount1Max > tokensOwed1 ? tokensOwed1 : params.amount1Max
        //     );

        // // the actual amounts collected are returned
        // (amount0, amount1) = pool.collect(
        //     recipient,
        //     position.tickLower,
        //     position.tickUpper,
        //     amount0Collect,
        //     amount1Collect
        // );

        // // sometimes there will be a few less wei than expected due to rounding down in core, but we just subtract the full amount expected
        // // instead of the actual amount so we can burn the token
        // (position.tokensOwed0, position.tokensOwed1) = (tokensOwed0 - amount0Collect, tokensOwed1 - amount1Collect);

        // emit Collect(params.tokenId, recipient, amount0Collect, amount1Collect);
    }

    /// @inheritdoc INonfungiblePositionManager
    entry burn(tokenId: nat) 
    // external payable override isAuthorizedForToken(tokenId) 
    {
        // Position storage position = positions_[tokenId];
        // require(position.liquidity == 0 && position.tokensOwed0 == 0 && position.tokensOwed1 == 0, 'Not cleared');
        // delete positions_[tokenId];
        // _burn(tokenId);
    }

    getter _getAndIncrementNonce(tokenId: nat) 
    // internal override returns (nat) 
    : nat {
        // return nat(positions_[tokenId].nonce++);
    }

    /// @inheritdoc IERC721
    getter getApproved(tokenId: nat) 
    // public view override(ERC721, IERC721) returns (address) 
    : address {
        // require(_exists(tokenId), 'ERC721: approved query for nonexistent token');

        // return positions_[tokenId].operator;
    }

    /// @dev Overrides _approve to use the operator in the position, which is packed with the position permit nonce
    entry _approve(to: address, tokenId: nat) 
    // internal override(ERC721) 
    {
        // positions_[tokenId].operator = to;
        // emit Approval(ownerOf(tokenId), to, tokenId);
    }
// }
