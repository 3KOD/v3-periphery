archetype SwapRouter(const factory: address)

constant INVALID_OPERATION: string = "ERR"
constant MIN_SQRT_RATIO: nat = 4295128739
constant MAX_SQRT_RATIO: nat = 1461446703485210103287273052203988822378723970342

record ExactInputSingleParams {
    tokenIn_InSParam: address;
    tokenOut_InSParam: address;
    fee_InSParam: nat;
    recipient_InSParam: address;
    deadline_InSParam: date;
    amountIn_InSParam: nat;
    amountOutMinimum_InSParam: nat;
    sqrtPriceLimitX96_InSParam: nat;
}

record ExactInputParams {
    path_InParam: bytes;
    recipient_InParam: address;
    deadline_InParam: date;
    amountIn_InParam: nat;
    amountOutMinimum_InParam: nat;
}

record ExactOutputSingleParams {
    tokenIn_OutSParam: address;
    tokenOut_OutSParam: address;
    fee_OutSParam: nat;
    recipient_OutSParam: address;
    deadline_OutSParam: date;
    amountOut_OutSParam: nat;
    amountInMaximum_OutSParam: nat;
    sqrtPriceLimitX96_OutSParam: nat;
}

record ExactOutputParams {
    path_OutParam: bytes;
    recipient_OutParam: address;
    deadline_OutParam: nat;
    amountOut_OutParam: nat;
    amountInMaximum_OutParam: nat;
}

function checkDeadline(deadline_: date): bool {
    do_require(now <= deadline_, "Transaction too old");
    return true
}

constant DEFAULT_AMOUNT_IN_CACHED: nat = 115_792_089_237_316_195_423_570_985_008_687_907_853_269_984_665_640_564_039_457_584_007_913_129_639_935

/// @dev Transient storage variable used for returning the computed amount in for an exact output swap.
variable amountInCached: nat = DEFAULT_AMOUNT_IN_CACHED

record SwapCallbackData {
    path_SwapCallbackData: bytes;
    payer_SwapCallbackData: address;
}

/// @inheritdoc IKodexV3SwapCallback
entry kodexV3SwapCallback(
    amount0Delta: int,
    amount1Delta: int,
    data_: bytes
) {
    // swaps entirely within 0-liquidity regions are not supported
    do_require((amount0Delta > 0) or (amount1Delta > 0), INVALID_OPERATION);
    // SwapCallbackData memory data = abi.decode(data_, (SwapCallbackData));
    const data: SwapCallbackData ?= unpack<SwapCallbackData>(data_) : INVALID_OPERATION;
    // (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();
    const decode_param ?= unpack<address * address * nat>(data.path_SwapCallbackData);
    const tokenIn_param: address = decode_param[0];
    const tokenOut_param: address = decode_param[1];
    const fee_param: nat = decode_param[2];

    const pool_param ?= call_view<address>(
        factory, 
        "computeAddress", 
        (tokenIn_param, tokenOut_param, fee_param)
    ): INVALID_OPERATION;
    do_require(caller = pool_param, INVALID_OPERATION);

    const isExactInput: bool = amount0Delta > 0 ? (tokenIn_param < tokenOut_param) : (tokenOut_param < tokenIn_param);
    const amountToPay_int: int = amount0Delta > 0 ?  amount0Delta : amount1Delta;
    const amountToPay: nat ?= int_to_nat(amountToPay_int) : INVALID_OPERATION;
    if (isExactInput = false) then begin
        amountInCached := amountToPay
    end
}

entry exactInputSingle(params: ExactInputSingleParams)
{
    do_require(checkDeadline(params.deadline_InSParam), INVALID_OPERATION);
    
    const tokenIn_param: address = params.tokenIn_InSParam;
    const tokenOut_param: address = params.tokenOut_InSParam;
    const fee_param: nat = params.fee_InSParam;

    var zeroForOne: bool = tokenIn_param < tokenOut_param;
    const poolAddress ?= call_view<address>(factory, "computeAddress", (tokenIn_param, tokenOut_param, fee_param)) : INVALID_OPERATION;
    const sqrtPriceLimitX96_int: int = (params.sqrtPriceLimitX96_InSParam = 0) ? (zeroForOne ? (MIN_SQRT_RATIO + 1i) : (MAX_SQRT_RATIO - 1)) : params.sqrtPriceLimitX96_InSParam;
    const sqrtPriceLimitX96_nat: nat ?= int_to_nat(sqrtPriceLimitX96_int) : INVALID_OPERATION;
    const path_param: bytes = pack((params.tokenIn_InSParam, params.tokenOut_InSParam, params.fee_InSParam));
    const pack_data: SwapCallbackData = {pack(path_param); caller};

    const retVal_swap ?= call_view<int * int>(poolAddress, "swap_view", (
        zeroForOne, 
        (params.amountIn_InSParam - 0), 
        sqrtPriceLimitX96_nat
        )
    ) : INVALID_OPERATION;
    transfer 0tz to poolAddress call swap<address * bool * int * nat * bytes>((
        params.recipient_InSParam, 
        zeroForOne, 
        (params.amountIn_InSParam - 0), 
        sqrtPriceLimitX96_nat,
        pack(pack_data)
    ));
    const amount0 = retVal_swap[0];
    const amount1 = retVal_swap[1];
    const amountOut_param ?= int_to_nat(-(zeroForOne ? amount1 : amount0)) : INVALID_OPERATION;

    do_require(amountOut_param >= params.amountOutMinimum_InSParam, "Too little received")
}

/// @inheritdoc ISwapRouter
entry exactOutputSingle(params: ExactOutputSingleParams)
{
    do_require(checkDeadline(params.deadline_OutSParam), INVALID_OPERATION);
    
    const tokenOut_param: address = params.tokenOut_OutSParam;
    const tokenIn_param: address = params.tokenIn_OutSParam;
    const fee_param: nat = params.fee_OutSParam;

    const zeroForOne: bool = (tokenIn_param < tokenOut_param);

    const path_param: bytes = pack((tokenOut_param, tokenIn_param, fee_param));
    const pack_data: SwapCallbackData = {pack(path_param); caller};
    
    const poolAddress ?= call_view<address>(factory, "computeAddress", (tokenIn_param, tokenOut_param, fee_param)) : INVALID_OPERATION;
    const sqrtPriceLimitX96_int: int = (params.sqrtPriceLimitX96_OutSParam = 0) ? (zeroForOne ? (MIN_SQRT_RATIO + 1i) : (MAX_SQRT_RATIO - 1)) : params.sqrtPriceLimitX96_OutSParam;
    const sqrtPriceLimitX96_nat: nat ?= int_to_nat(sqrtPriceLimitX96_int) : INVALID_OPERATION;

    const retVal_swap ?= call_view<int * int>(poolAddress, "swap_view", (zeroForOne, -params.amountOut_OutSParam, sqrtPriceLimitX96_nat)) : INVALID_OPERATION;
    transfer 0tz to poolAddress call swap<address * bool * int * nat * bytes>((
        params.recipient_OutSParam, 
        zeroForOne, 
        -params.amountOut_OutSParam, 
        sqrtPriceLimitX96_nat,
        pack(pack_data)
    ));
    const amount0Delta = retVal_swap[0];
    const amount1Delta = retVal_swap[1];
    const amountIn_int = zeroForOne ? amount0Delta : amount1Delta;
    const amountIn: nat ?= int_to_nat(amountIn_int) : INVALID_OPERATION;
    const amountOutReceived_int: int = zeroForOne ? -amount1Delta : -amount0Delta;
    const amountOutReceived: nat ?= int_to_nat(amountOutReceived_int) : INVALID_OPERATION;
    // it's technically possible to not receive the full output amount,
    // so if no price limit has been specified, require this possibility away
    if (params.sqrtPriceLimitX96_OutSParam = 0) then 
        do_require(amountOutReceived = params.amountOut_OutSParam, INVALID_OPERATION);

    do_require(amountIn <= params.amountInMaximum_OutSParam, "Too much requested");
    // has to be reset even though we don't use it in the single hop case
    amountInCached := DEFAULT_AMOUNT_IN_CACHED
}
